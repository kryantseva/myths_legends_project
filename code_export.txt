backend\docker-compose.yml

services:
  db:
    image: postgis/postgis:16-3.4
    restart: always
    environment:
      POSTGRES_DB: myths_legends_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: car
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data/
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 5s
      timeout: 5s
      retries: 5
  web:
    build: .
    command: bash -c "/usr/local/bin/wait-for-it.sh -h db -p 5432 -- python manage.py migrate && python manage.py runserver 0.0.0.0:8000"
    volumes:
      - .:/app
      - media_data:/app/media
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
    environment:
      POSTGRES_DB: myths_legends_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: car
      POSTGRES_HOST: db
      POSTGRES_PORT: 5432
      SECRET_KEY: mysecretkey123
      DJANGO_SETTINGS_MODULE: myths_legends_project.settings

volumes:
  pgdata:
  media_data:

backend\manage.py

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myths_legends_project.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


backend\myths_legends_project\asgi.py

"""
ASGI config for myths_legends_project project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myths_legends_project.settings')

application = get_asgi_application()


backend\myths_legends_project\settings.py

from pathlib import Path
import environ
import os

BASE_DIR = Path(__file__).resolve().parent.parent

env = environ.Env()
dot_env_path = BASE_DIR / '.env'
if dot_env_path.exists():
    env.read_env(str(dot_env_path))

SECRET_KEY = env('SECRET_KEY')

DEBUG = True

ALLOWED_HOSTS = ["localhost", "127.0.0.1", "0.0.0.0"]

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',
    'places.apps.PlacesConfig',
    'users',
    'rest_framework',
    'rest_framework.authtoken',
    'django_filters',
    'corsheaders',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ORIGIN_WHITELIST = ['http://localhost:3000']

CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://127.0.0.1:3000", 
]

ROOT_URLCONF = 'myths_legends_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth', 
                'django.contrib.messages.context_processors.messages'
            ],
        },
    },
]

WSGI_APPLICATION = 'myths_legends_project.wsgi.application'

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.SearchFilter',
        'rest_framework.filters.OrderingFilter',
    ]
}

DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': env('POSTGRES_DB'),
        'USER': env('POSTGRES_USER'),
        'PASSWORD': env('POSTGRES_PASSWORD'),
        'HOST': env('POSTGRES_HOST', default='localhost'),
        'PORT': env('POSTGRES_PORT', default=5432),
        'CONN_MAX_AGE': 60,
        'OPTIONS': {
            'connect_timeout': 5,
            'client_encoding': 'UTF8',
        }
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

STATIC_URL = 'static/'

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

CORS_ALLOW_ALL_ORIGINS = True

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media' 

TEST_RUNNER = 'django.test.runner.DiscoverRunner'

backend\myths_legends_project\urls.py

# backend/myths_legends_project/urls.py

from django.contrib import admin
from django.urls import path, include

# from drf_yasg.openapi import APIKey, IN_HEADER # Эта строка должна быть закомментирована/удалена

from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('places.api.urls')),
    path('api/auth/', include('users.urls')),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

backend\myths_legends_project\wsgi.py

"""
WSGI config for myths_legends_project project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https:
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myths_legends_project.settings')

application = get_wsgi_application()


backend\places\admin.py

# backend/places/admin.py

from django.contrib import admin
from django.contrib.gis.admin import OSMGeoAdmin # Используем OSMGeoAdmin для отображения карты
from .models import Place, UserNote

# Регистрируем модель Place с использованием OSMGeoAdmin для интерактивной карты
@admin.register(Place)
class PlaceAdmin(OSMGeoAdmin):
    list_display = ('name', 'categories', 'created_at', 'updated_at')
    search_fields = ('name', 'description', 'categories')
    # Добавляем поля latitude и longitude в readonly_fields, если они не являются частью редактирования
    # Если вы хотите редактировать координаты напрямую, то latitude/longitude должны быть в fields,
    # но PointField будет отображаться как текст. OSMGeoAdmin автоматически создает виджет карты для PointField.
    # fieldsets = (
    #     (None, {
    #         'fields': ('name', 'description', 'location', 'categories', 'image')
    #     }),
    # )


@admin.register(UserNote)
class UserNoteAdmin(admin.ModelAdmin):
    list_display = ('place', 'user', 'moderation_status', 'created_at')
    list_filter = ('moderation_status',)
    search_fields = ('place__name', 'user__username', 'text')

backend\places\api\permissions.py

# places/api/permissions.py
from rest_framework import permissions

class IsOwnerOrAdminOrReadOnly(permissions.BasePermission):
    """
    Custom permission to only allow owners of an object, or admins, to edit/delete it.
    Allows read access to anyone.
    """
    def has_object_permission(self, request, view, obj):
        if request.method in permissions.SAFE_METHODS:
            return True
        # Write permissions are only allowed to the owner or admin.
        return obj.owner == request.user or request.user.is_superuser

class IsOwnerOrAdmin(permissions.BasePermission):
    """
    Custom permission to only allow owners of an object, or admins, to view, edit, or delete it.
    """
    def has_object_permission(self, request, view, obj):
        # Write permissions are only allowed to the owner or admin.
        return obj.user == request.user or request.user.is_superuser

# --- ADD THIS NEW PERMISSION CLASS ---
class IsModeratorOrAdmin(permissions.BasePermission):
    """
    Custom permission to only allow users in 'Moderators' group or superusers.
    """
    def has_permission(self, request, view):
        return request.user and (request.user.is_superuser or request.user.groups.filter(name='Moderators').exists())

    def has_object_permission(self, request, view, obj):
        # Optionally, you can add object-level permission here if needed,
        # but for moderation, has_permission is usually sufficient.
        return self.has_permission(request, view)

backend\places\api\serializers.py

from rest_framework_gis.serializers import GeoFeatureModelSerializer
from rest_framework import serializers
from django.contrib.auth.models import User
from places.models import Place, UserNote, Comment
from django.db.models import Avg, Count, F, Q

class UserSerializer(serializers.ModelSerializer):
    groups = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = ['id', 'username', 'is_superuser', 'groups']

    def get_groups(self, obj):
        return [group.name for group in obj.groups.all()]  # Fetch group names

class UserNoteSerializer(serializers.ModelSerializer):
    author_username = serializers.CharField(source='user.username', read_only=True)
    user = UserSerializer()  # Nested serializer to include groups

    class Meta:
        model = UserNote
        fields = ['id', 'place', 'user', 'author_username', 'text', 'rating', 'image', 'moderation_status', 'created_at', 'updated_at']
        read_only_fields = ['user', 'moderation_status', 'created_at', 'updated_at']

class CommentSerializer(serializers.ModelSerializer):
    author_username = serializers.CharField(source='user.username', read_only=True)
    user = UserSerializer()  # Nested serializer to include groups

    class Meta:
        model = Comment
        fields = ['id', 'note', 'user', 'author_username', 'text', 'moderation_status', 'created_at', 'updated_at']
        read_only_fields = ['user', 'moderation_status', 'created_at', 'updated_at']

class PlaceSerializer(GeoFeatureModelSerializer):
    distance = serializers.SerializerMethodField()
    notes_count = serializers.SerializerMethodField()
    avg_rating = serializers.SerializerMethodField()
    current_user_note = serializers.SerializerMethodField()
    owner = UserSerializer()  # Nested serializer to include groups
    image = serializers.ImageField(required=False, allow_null=True)

    class Meta:
        model = Place
        geo_field = "location"
        fields = [
            "id", "name", "description", "location", "categories", "status",
            "created_at", "updated_at", "image", "distance",
            "notes_count", "avg_rating", "current_user_note", "owner"
        ]
        read_only_fields = ['created_at', 'updated_at', 'status', 'notes_count', 'avg_rating', 'current_user_note']

    def get_distance(self, obj):
        user_location = self.context.get('user_location')
        if user_location and obj.location:
            dist = getattr(obj, 'distance', None)
            if dist is not None:
                return round(dist.m, 2)
        return None

    def get_notes_count(self, obj):
        return obj.user_notes.filter(moderation_status='approved').count()

    def get_avg_rating(self, obj):
        avg = obj.user_notes.filter(moderation_status='approved', rating__isnull=False).aggregate(Avg('rating'))['rating__avg']
        return round(avg, 1) if avg else None

    def get_current_user_note(self, obj):
        request = self.context.get('request')
        if request and request.user.is_authenticated:
            try:
                note = obj.user_notes.get(user=request.user)
                return UserNoteSerializer(note, context={'request': request}).data
            except UserNote.DoesNotExist:
                return None
        return None

backend\places\api\urls.py

# backend/places/api/urls.py

from rest_framework.routers import DefaultRouter
from .viewsets import PlaceViewSet, UserNoteViewSet, CommentViewSet

router = DefaultRouter()
router.register(r'places', PlaceViewSet, basename='place')
router.register(r'notes', UserNoteViewSet, basename='usernote')
router.register(r'comments', CommentViewSet, basename='comment') # Убедитесь, что эта строка есть

urlpatterns = router.urls

backend\places\api\viewsets.py

from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated, AllowAny, IsAdminUser
from django.db.models import Avg, Count, Q
from django.db.models.functions import Coalesce
from django.contrib.gis.geos import Point
from django.contrib.gis.measure import D
from django.contrib.gis.db.models.functions import Distance

from places.models import Place, UserNote, Comment
from .serializers import PlaceSerializer, UserNoteSerializer, CommentSerializer
from .permissions import IsOwnerOrAdminOrReadOnly, IsOwnerOrAdmin, IsModeratorOrAdmin
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter

class PlaceViewSet(viewsets.ModelViewSet):
    queryset = Place.objects.all().select_related('owner').prefetch_related('user_notes', 'favorites')
    serializer_class = PlaceSerializer
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['status', 'categories']
    search_fields = ['name', 'description', 'categories']
    ordering_fields = ['created_at', 'name', 'notes_count', 'avg_rating', 'distance']

    def get_permissions(self):
        if self.action in ['create', 'update', 'partial_update', 'destroy', 'toggle_favorite']:
            self.permission_classes = [IsAuthenticated, IsOwnerOrAdminOrReadOnly]
        elif self.action in ['list', 'retrieve', 'nearest']:
            self.permission_classes = [AllowAny]
        elif self.action in ['approve', 'reject']:
            self.permission_classes = [IsAdminUser | IsModeratorOrAdmin]
        return super().get_permissions()

    def get_queryset(self):
        queryset = super().get_queryset()

        queryset = queryset.annotate(
            notes_count=Count('user_notes', filter=Q(user_notes__moderation_status='approved')),
            avg_rating=Coalesce(Avg('user_notes__rating', filter=Q(user_notes__moderation_status='approved', user_notes__rating__isnull=False)), 0.0)
        )

        if not (self.request.user.is_superuser or self.request.user.groups.filter(name='Moderators').exists()):
            queryset = queryset.filter(status='approved')

        return queryset

    def perform_create(self, serializer):
        serializer.save(owner=self.request.user, status='pending')

    @action(detail=False, methods=['get'])
    def nearest(self, request):
        latitude = request.query_params.get('lat')
        longitude = request.query_params.get('lon')
        radius_km = request.query_params.get('radius_km')

        if not (latitude and longitude):
            return Response({"detail": "Parameters 'lat' and 'lon' are required."}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            user_location = Point(float(longitude), float(latitude), srid=4326)
        except ValueError:
            return Response({"detail": "Invalid values for 'lat' or 'lon'."}, status=status.HTTP_400_BAD_REQUEST)

        queryset = self.get_queryset()

        if radius_km:
            try:
                radius_meters = float(radius_km) * 1000
                queryset = queryset.filter(location__dwithin=(user_location, D(m=radius_meters)))
            except ValueError:
                return Response({"detail": "Invalid value for 'radius_km'."}, status=status.HTTP_400_BAD_REQUEST)

        queryset = queryset.annotate(distance=Distance('location', user_location)).order_by('distance')

        serializer = self.get_serializer(queryset, many=True, context={'request': request, 'user_location': user_location})
        return Response(serializer.data)

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def toggle_favorite(self, request, pk=None):
        place = self.get_object()
        user = request.user
        if user in place.favorites.all():
            place.favorites.remove(user)
            return Response({"status": "removed from favorites"}, status=status.HTTP_200_OK)
        else:
            place.favorites.add(user)
            return Response({"status": "added to favorites"}, status=status.HTTP_201_CREATED)

    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser | IsModeratorOrAdmin])
    def approve(self, request, pk=None):
        place = self.get_object()
        if not place.can_moderate(request.user):
            return Response({'detail': 'Permission denied.'}, status=status.HTTP_403_FORBIDDEN)
        place.status = 'approved'
        place.save()
        return Response({'status': 'place approved', 'id': place.id}, status=status.HTTP_200_OK)

    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser | IsModeratorOrAdmin])
    def reject(self, request, pk=None):
        place = self.get_object()
        place.status = 'rejected'
        place.save()
        return Response({'status': 'place rejected', 'id': place.id}, status=status.HTTP_200_OK)


class UserNoteViewSet(viewsets.ModelViewSet):
    queryset = UserNote.objects.all().select_related('user', 'place')
    serializer_class = UserNoteSerializer
    permission_classes = [IsAuthenticated, IsOwnerOrAdminOrReadOnly]
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['place', 'moderation_status']
    search_fields = ['text']
    ordering_fields = ['created_at', 'rating', 'updated_at']

    def get_permissions(self):
        if self.action in ['approve', 'reject']:
            self.permission_classes = [IsAdminUser | IsModeratorOrAdmin]
        return super().get_permissions()

    def get_queryset(self):
        queryset = super().get_queryset()
        if not (self.request.user.is_superuser or self.request.user.groups.filter(name='Moderators').exists()):
            queryset = queryset.filter(moderation_status='approved')
        return queryset

    def perform_create(self, serializer):
        serializer.save(user=self.request.user, moderation_status='pending')

    def perform_update(self, serializer):
        if serializer.instance.moderation_status == 'approved' and self.request.user == serializer.instance.user:
            serializer.save(moderation_status='pending')
        else:
            serializer.save()

    def perform_destroy(self, instance):
        instance.delete()

    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser | IsModeratorOrAdmin])
    def approve(self, request, pk=None):
        note = self.get_object()
        note.moderation_status = 'approved'
        note.save()
        return Response({'status': 'note approved', 'id': note.id}, status=status.HTTP_200_OK)

    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser | IsModeratorOrAdmin])
    def reject(self, request, pk=None):
        note = self.get_object()
        note.moderation_status = 'rejected'
        note.save()
        return Response({'status': 'note rejected', 'id': note.id}, status=status.HTTP_200_OK)


class CommentViewSet(viewsets.ModelViewSet):
    queryset = Comment.objects.all().select_related('user', 'note')
    serializer_class = CommentSerializer
    permission_classes = [IsAuthenticated, IsOwnerOrAdminOrReadOnly]
    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ['note', 'moderation_status']
    search_fields = ['text']
    ordering_fields = ['created_at', 'updated_at']

    def get_permissions(self):
        if self.action in ['approve', 'reject']:
            self.permission_classes = [IsAdminUser | IsModeratorOrAdmin]
        return super().get_permissions()

    def get_queryset(self):
        queryset = super().get_queryset()
        # Remove invalid annotation for user_notes since Comment doesn't relate to user_notes directly
        if not (self.request.user.is_superuser or self.request.user.groups.filter(name='Moderators').exists()):
            queryset = queryset.filter(moderation_status='approved')
        return queryset

    def perform_create(self, serializer):
        serializer.save(user=self.request.user, moderation_status='pending')

    def perform_update(self, serializer):
        if serializer.instance.moderation_status == 'approved' and self.request.user == serializer.instance.user:
            serializer.save(moderation_status='pending')
        else:
            serializer.save()

    def perform_destroy(self, instance):
        instance.delete()

    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser | IsModeratorOrAdmin])
    def approve(self, request, pk=None):
        comment = self.get_object()
        comment.moderation_status = 'approved'
        comment.save()
        return Response({'status': 'comment approved', 'id': comment.id}, status=status.HTTP_200_OK)

    @action(detail=True, methods=['patch'], permission_classes=[IsAdminUser | IsModeratorOrAdmin])
    def reject(self, request, pk=None):
        comment = self.get_object()
        comment.moderation_status = 'rejected'
        comment.save()
        return Response({'status': 'comment rejected', 'id': comment.id}, status=status.HTTP_200_OK)

backend\places\apps.py

# backend/places/apps.py

from django.apps import AppConfig

class PlacesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'places'

    def ready(self):
        import places.signals # Убедитесь, что эта строка есть и она правильная

backend\places\filters.py

import django_filters
from places.models import Place, UserNote, Comment

class PlaceFilter(django_filters.FilterSet):
    name = django_filters.CharFilter(lookup_expr='icontains')
    categories = django_filters.CharFilter(lookup_expr='icontains')
    status = django_filters.ChoiceFilter(choices=Place.STATUS_CHOICES)

    class Meta:
        model = Place
        fields = ['name', 'categories', 'status', 'owner']

class UserNoteFilter(django_filters.FilterSet):
    text = django_filters.CharFilter(lookup_expr='icontains')
    moderation_status = django_filters.ChoiceFilter(choices=UserNote.moderation_status.field.choices)
    rating = django_filters.RangeFilter() 
    
    class Meta:
        model = UserNote
        fields = ['place', 'user', 'moderation_status', 'rating']

class CommentFilter(django_filters.FilterSet):
    text = django_filters.CharFilter(lookup_expr='icontains')
    moderation_status = django_filters.ChoiceFilter(choices=Comment.moderation_status.field.choices)

    class Meta:
        model = Comment
        fields = ['note', 'user', 'moderation_status']

backend\places\management\commands\populate_data.py

from django.core.management.base import BaseCommand
from django.contrib.auth import get_user_model
from django.contrib.gis.geos import Point
from places.models import Place, UserNote, Comment
from rest_framework.authtoken.models import Token
import random
import os
from django.core.files import File
from io import BytesIO
from PIL import Image

User = get_user_model()

class Command(BaseCommand):
    help = 'Populates the database with diverse places, notes, and comments for demonstration.'

    def _create_dummy_image(self, width=100, height=100, color=(255, 0, 0), text="Placeholder"):
        """Creates a dummy image file in memory."""
        image = Image.new('RGB', (width, height), color)
        # Optionally add text to the image
        # from PIL import ImageDraw, ImageFont
        # draw = ImageDraw.Draw(image)
        # try:
        #     font = ImageFont.truetype("arial.ttf", 15)
        # except IOError:
        #     font = ImageFont.load_default()
        # draw.text((10, 10), text, font=font, fill=(0, 0, 0))

        image_io = BytesIO()
        image.save(image_io, format='PNG')
        image_name = f'dummy_{width}x{height}_{random.randint(1000,9999)}.png'
        return File(image_io, name=image_name)


    def handle(self, *args, **options):
        self.stdout.write(self.style.WARNING('Cleaning up existing data...'))
        Comment.objects.all().delete()
        UserNote.objects.all().delete()
        Place.objects.all().delete()
        User.objects.filter(is_superuser=False).delete()
        
        # Очищаем папку media перед запуском, чтобы не было старых файлов
        media_root = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../../media')
        if os.path.exists(media_root):
            for root, dirs, files in os.walk(media_root):
                for f in files:
                    os.unlink(os.path.join(root, f))
                for d in dirs:
                    os.rmdir(os.path.join(root, d))
        self.stdout.write(self.style.SUCCESS('Existing data cleaned and media folder cleared.'))

        self.stdout.write(self.style.MIGRATE_HEADING('Creating users...'))
        users_data = [
            {'username': 'testuser1', 'email': 'user1@example.com', 'password': 'password123'},
            {'username': 'testuser2', 'email': 'user2@example.com', 'password': 'password123'},
            {'username': 'moderator', 'email': 'moderator@example.com', 'password': 'password123'},
        ]
        
        regular_users = []
        for data in users_data:
            user, created = User.objects.get_or_create(username=data['username'], defaults={'email': data['email']})
            if created:
                user.set_password(data['password'])
                user.save()
                Token.objects.get_or_create(user=user)
                regular_users.append(user)
                self.stdout.write(self.style.SUCCESS(f'Created user: {user.username}'))
            else:
                self.stdout.write(self.style.WARNING(f'User {user.username} already exists.'))
                regular_users.append(user)

        superuser = User.objects.get(username='admin')
        Token.objects.get_or_create(user=superuser)
        self.stdout.write(self.style.SUCCESS(f'Ensured token for superuser: {superuser.username}'))


        self.stdout.write(self.style.MIGRATE_HEADING('Creating diverse places in Kazan...'))

        places_data = [
            {'name': 'Казанский Кремль', 'description': 'Историческая крепость и объект Всемирного наследия ЮНЕСКО.', 'lat': 55.7996, 'lon': 49.1064, 'categories': 'Историческое, Крепость', 'owner': superuser, 'status': 'approved'},
            {'name': 'Мечеть Кул-Шариф', 'description': 'Главная соборная мечеть Татарстана, символ Казани.', 'lat': 55.8000, 'lon': 49.1083, 'categories': 'Культовое, Мечеть', 'owner': superuser, 'status': 'approved'},
            {'name': 'Башня Сююмбике', 'description': 'Наклонная башня Казанского Кремля, с ней связана легенда о царице Сююмбике.', 'lat': 55.8006, 'lon': 49.1085, 'categories': 'Историческое, Башня, Легенда', 'owner': superuser, 'status': 'approved'},
            {'name': 'Петропавловский собор', 'description': 'Образец русского барокко, выдающаяся архитектурная памятка Казани.', 'lat': 55.7891, 'lon': 49.1235, 'categories': 'Культовое, Собор', 'owner': superuser, 'status': 'approved'},
            {'name': 'Старо-Татарская слобода', 'description': 'Исторический район Казани, где сохранились традиции и архитектура татарского народа.', 'lat': 55.7760, 'lon': 49.1200, 'categories': 'Историческое, Район', 'owner': superuser, 'status': 'approved'},
            {'name': 'Кремлёвская набережная', 'description': 'Современная набережная реки Казанки, популярное место для прогулок.', 'lat': 55.8075, 'lon': 49.1150, 'categories': 'Отдых, Набережная', 'owner': superuser, 'status': 'approved'},
            {'name': 'Центр семьи Казан', 'description': 'ЗАГС в форме казана, современный символ города и смотровая площадка.', 'lat': 55.8118, 'lon': 49.0910, 'categories': 'Современное, Достопримечательность', 'owner': superuser, 'status': 'approved'},
            
            {'name': 'Легенда о Зиланте', 'description': 'Символ Казани, мифическое существо из татарского фольклора.', 'lat': 55.8050, 'lon': 49.1000, 'categories': 'Миф, Символ', 'owner': regular_users[0], 'status': 'approved'},
            {'name': 'Дом Шамиля', 'description': 'Особняк купца Шамиля, связанный с городскими легендами.', 'lat': 55.7820, 'lon': 49.1250, 'categories': 'Легенда, Архитектура', 'owner': regular_users[0], 'status': 'pending'},
            {'name': 'Чертово городище', 'description': 'Место древнего булгарского поселения, окутанное мифами.', 'lat': 55.7600, 'lon': 49.1100, 'categories': 'Историческое, Миф', 'owner': regular_users[0], 'status': 'rejected'},

            {'name': 'Легенда о Казанской иконе Божией Матери', 'description': 'Одна из самых почитаемых икон России, с ней связано множество чудес.', 'lat': 55.7800, 'lon': 49.1200, 'categories': 'Легенда, Культовое', 'owner': regular_users[1], 'status': 'approved'},
            {'name': 'Булак', 'description': 'Канал в центре Казани, с ним связаны свои городские истории.', 'lat': 55.7890, 'lon': 49.1180, 'categories': 'Отдых, История', 'owner': regular_users[1], 'status': 'pending'},

            {'name': 'Озеро Кабан', 'description': 'Система озер, на дне которых, по легенде, хранится ханская казна.', 'lat': 55.7500, 'lon': 49.1500, 'categories': 'Легенда, Природа', 'owner': regular_users[2], 'status': 'approved'},
            {'name': 'Театр им. Г. Камала', 'description': 'Татарский государственный академический театр.', 'lat': 55.7818, 'lon': 49.1230, 'categories': 'Культурное, Театр', 'owner': regular_users[2], 'status': 'approved'},
        ]

        created_places = []
        for data in places_data:
            place_image = self._create_dummy_image(
                width=random.randint(400, 800), 
                height=random.randint(300, 600), 
                color=(random.randint(0,255), random.randint(0,255), random.randint(0,255)),
                text=data['name']
            ) if random.random() < 0.7 else None # 70% шанс на изображение
            
            place, created = Place.objects.get_or_create(
                name=data['name'],
                defaults={
                    'description': data['description'],
                    'location': Point(data['lon'], data['lat']),
                    'categories': data['categories'],
                    'owner': data['owner'],
                    'status': data['status'],
                    'image': place_image # Привязываем изображение
                }
            )
            created_places.append(place)
            if created:
                self.stdout.write(self.style.SUCCESS(f'Created place: {place.name} (Status: {place.status})'))
            else:
                self.stdout.write(self.style.WARNING(f'Place "{place.name}" already exists. (Status: {place.status})'))

        self.stdout.write(self.style.MIGRATE_HEADING('Creating diverse notes for places...'))

        note_texts = [
            "Очень понравилось! Обязательно посетите.",
            "Интересное место, но ожидал большего. Немного завышены ожидания.",
            "Невероятно красивое и познавательное место. 5 из 5!",
            "Спорное место, требует дополнительного изучения.",
            "Разочарован. Не нашёл ничего интересного.",
            "Замечательное место для прогулок и размышлений.",
            "Просто потрясающе! Вернусь сюда ещё не раз.",
            "Неплохо, но есть куда стремиться.",
            "Дух истории здесь ощущается очень сильно.",
            "Место силы, определенно."
        ]
        
        for user_idx, user in enumerate(regular_users):
            self.stdout.write(self.style.MIGRATE_HEADING(f'Creating notes for {user.username}...'))
            for i, place in enumerate(created_places):
                if random.random() < 0.6:
                    status = 'approved'
                    if random.random() < 0.3:
                        status = 'pending'
                    elif random.random() < 0.1:
                        status = 'rejected'
                    
                    rating = random.randint(1, 5) if random.random() < 0.8 else None
                    
                    note_image = None
                    if random.random() < 0.4: # 40% шанс на наличие изображения
                         note_image = self._create_dummy_image(
                            width=random.randint(200, 500), 
                            height=random.randint(150, 400), 
                            color=(random.randint(0,255), random.randint(0,255), random.randint(0,255)),
                            text=f"Note {i}"
                        )
                    
                    note = UserNote.objects.create(
                        user=user,
                        place=place,
                        text=f"{random.choice(note_texts)} (ID места: {place.id})",
                        moderation_status=status,
                        rating=rating,
                        image=note_image # Привязываем изображение
                    )
                    self.stdout.write(self.style.SUCCESS(f'  Created note for {user.username} about {place.name} (Status: {status}, Rating: {rating})'))

        self.stdout.write(self.style.MIGRATE_HEADING('Creating diverse comments for notes...'))

        comment_texts = [
            "Согласен!",
            "Отличная заметка, спасибо!",
            "Не совсем понял, можно подробнее?",
            "Интересный взгляд, но у меня другое мнение.",
            "Очень помогло, спасибо!",
            "Полностью поддерживаю!",
            "Не согласен с этим мнением.",
            "Надо перепроверить информацию.",
            "Кратко и по делу."
        ]

        for note in UserNote.objects.all():
            for user in regular_users:
                if random.random() < 0.5:
                    status = 'approved'
                    if random.random() < 0.3:
                        status = 'pending'
                    elif random.random() < 0.1:
                        status = 'rejected'
                    
                    try:
                        Comment.objects.create(
                            user=user,
                            note=note,
                            text=f"{random.choice(comment_texts)} (к заметке {note.id})",
                            moderation_status=status
                        )
                        self.stdout.write(self.style.SUCCESS(f'  Created comment by {user.username} for note {note.id} (Status: {status})'))
                    except Exception as e:
                        self.stdout.write(self.style.ERROR(f'  Failed to create comment for note {note.id} by {user.username}: {e}'))

        self.stdout.write(self.style.SUCCESS('Database population complete!'))

        self.stdout.write(self.style.MIGRATE_HEADING('\n--- User Tokens ---'))
        for user in regular_users:
            token = Token.objects.get(user=user)
            self.stdout.write(f'User: {user.username}, Token: {token.key}')
        
        superuser_token = Token.objects.get(user=superuser)
        self.stdout.write(f'User: {superuser.username} (Superuser), Token: {superuser_token.key}')
        self.stdout.write(self.style.MIGRATE_HEADING('-------------------\n'))

backend\places\migrations\0001_initial.py

# Generated by Django 4.2.7 on 2025-06-05 04:48

from django.conf import settings
import django.contrib.gis.db.models.fields
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="Place",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "name",
                    models.CharField(
                        db_index=True, max_length=255, verbose_name="Название места"
                    ),
                ),
                (
                    "description",
                    models.TextField(
                        verbose_name="Описание (историческая справка, мифы, легенды)"
                    ),
                ),
                (
                    "location",
                    django.contrib.gis.db.models.fields.PointField(
                        geography=True,
                        srid=4326,
                        verbose_name="Географические координаты (долгота, широта)",
                    ),
                ),
                (
                    "categories",
                    models.CharField(
                        blank=True,
                        db_index=True,
                        max_length=255,
                        null=True,
                        verbose_name="Категории (например: миф, легенда, историческое место)",
                    ),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Ожидает модерации"),
                            ("approved", "Одобрено"),
                            ("rejected", "Отклонено"),
                        ],
                        db_index=True,
                        default="pending",
                        max_length=50,
                        verbose_name="Статус модерации",
                    ),
                ),
                (
                    "image",
                    models.ImageField(
                        blank=True,
                        null=True,
                        upload_to="place_images/",
                        verbose_name="Изображение места",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True, db_index=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "average_rating",
                    models.DecimalField(
                        decimal_places=2,
                        default=0.0,
                        max_digits=3,
                        verbose_name="Средний рейтинг",
                    ),
                ),
                (
                    "rating_count",
                    models.IntegerField(default=0, verbose_name="Количество оценок"),
                ),
                (
                    "favorites",
                    models.ManyToManyField(
                        blank=True,
                        related_name="favorite_places",
                        to=settings.AUTH_USER_MODEL,
                        verbose_name="Избранные пользователи",
                    ),
                ),
                (
                    "owner",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="places",
                        to=settings.AUTH_USER_MODEL,
                        verbose_name="Владелец",
                    ),
                ),
            ],
            options={
                "verbose_name": "Место",
                "verbose_name_plural": "Места",
                "ordering": ["name"],
            },
        ),
        migrations.CreateModel(
            name="UserNote",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("text", models.TextField(verbose_name="Текст заметки")),
                (
                    "moderation_status",
                    models.CharField(
                        choices=[
                            ("pending", "Ожидает модерации"),
                            ("approved", "Одобрено"),
                            ("rejected", "Отклонено"),
                        ],
                        db_index=True,
                        default="pending",
                        max_length=50,
                        verbose_name="Статус модерации",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True, db_index=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "rating",
                    models.IntegerField(
                        blank=True,
                        null=True,
                        validators=[
                            django.core.validators.MinValueValidator(1),
                            django.core.validators.MaxValueValidator(5),
                        ],
                        verbose_name="Оценка места",
                    ),
                ),
                (
                    "image",
                    models.ImageField(
                        blank=True,
                        null=True,
                        upload_to="note_images/",
                        verbose_name="Изображение к заметке",
                    ),
                ),
                (
                    "place",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="user_notes",
                        to="places.place",
                        verbose_name="Место",
                    ),
                ),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                        verbose_name="Пользователь",
                    ),
                ),
            ],
            options={
                "verbose_name": "Заметка пользователя",
                "verbose_name_plural": "Заметки пользователей",
                "unique_together": {("place", "user")},
            },
        ),
        migrations.CreateModel(
            name="Comment",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("text", models.TextField(verbose_name="Текст комментария")),
                (
                    "moderation_status",
                    models.CharField(
                        choices=[
                            ("pending", "Ожидает модерации"),
                            ("approved", "Одобрено"),
                            ("rejected", "Отклонено"),
                        ],
                        db_index=True,
                        default="pending",
                        max_length=50,
                        verbose_name="Статус модерации",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True, db_index=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "note",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="comments",
                        to="places.usernote",
                        verbose_name="Заметка",
                    ),
                ),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                        verbose_name="Пользователь",
                    ),
                ),
            ],
            options={
                "verbose_name": "Комментарий",
                "verbose_name_plural": "Комментарии",
                "ordering": ["created_at"],
            },
        ),
    ]


backend\places\migrations\__init__.py



backend\places\models.py

from django.contrib.gis.db import models
from django.contrib.auth import get_user_model
from django.core.validators import MinValueValidator, MaxValueValidator
from django.db.models import Avg, Count
from django.db.models.functions import Coalesce

User = get_user_model()

class Place(models.Model):
    name = models.CharField(max_length=255, verbose_name="Название места", db_index=True)
    description = models.TextField(verbose_name="Описание (историческая справка, мифы, легенды)")
    location = models.PointField(srid=4326, geography=True, verbose_name="Географические координаты (долгота, широта)")
    categories = models.CharField(
        max_length=255,
        verbose_name="Категории (например: миф, легенда, историческое место)",
        blank=True,
        null=True,
        db_index=True
    )
    STATUS_CHOICES = [
        ('pending', 'Ожидает модерации'),
        ('approved', 'Одобрено'),
        ('rejected', 'Отклонено'),
    ]
    status = models.CharField(
        max_length=50,
        choices=STATUS_CHOICES,
        default='pending',
        verbose_name="Статус модерации",
        db_index=True
    )
    image = models.ImageField(upload_to='place_images/', blank=True, null=True, verbose_name="Изображение места")
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)
    owner = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='places',
        verbose_name="Владелец",
        db_index=True
    )
    favorites = models.ManyToManyField(
        User,
        related_name='favorite_places',
        blank=True,
        verbose_name="Избранные пользователи"
    )
    average_rating = models.DecimalField(
        max_digits=3,
        decimal_places=2,
        default=0.0,
        verbose_name="Средний рейтинг"
    )
    rating_count = models.IntegerField(
        default=0,
        verbose_name="Количество оценок"
    )

    class Meta:
        verbose_name = "Место"
        verbose_name_plural = "Места"
        ordering = ['name']

    def __str__(self):
        return self.name

    def update_average_rating(self):
        approved_notes = self.user_notes.filter(moderation_status='approved', rating__isnull=False)
        average_rating_data = approved_notes.aggregate(
            avg_rating=Coalesce(Avg('rating'), 0.0),
            count_rating=Count('rating')
        )
        self.average_rating = average_rating_data['avg_rating']
        self.rating_count = average_rating_data['count_rating']
        self.save()

    # Ensure status can be updated during moderation
    def can_moderate(self, user):
        return user.is_superuser or user.groups.filter(name='Moderators').exists()


class UserNote(models.Model):
    place = models.ForeignKey(Place, on_delete=models.CASCADE, related_name='user_notes', verbose_name="Место", db_index=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name="Пользователь", db_index=True)
    text = models.TextField(verbose_name="Текст заметки")
    moderation_status = models.CharField(
        max_length=50,
        choices=[('pending', 'Ожидает модерации'), ('approved', 'Одобрено'), ('rejected', 'Отклонено')],
        default='pending',
        verbose_name="Статус модерации",
        db_index=True
    )
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)
    rating = models.IntegerField(
        null=True,
        blank=True,
        validators=[MinValueValidator(1), MaxValueValidator(5)],
        verbose_name="Оценка места"
    )
    image = models.ImageField(
        upload_to='note_images/',
        blank=True,
        null=True,
        verbose_name="Изображение к заметке"
    )

    class Meta:
        verbose_name = "Заметка пользователя"
        verbose_name_plural = "Заметки пользователей"
        unique_together = ('place', 'user')

    def __str__(self):
        return f"Заметка {self.user.username} о {self.place.name}"

    # Ensure moderation status can be updated
    def can_moderate(self, user):
        return user.is_superuser or user.groups.filter(name='Moderators').exists()


class Comment(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name="Пользователь", db_index=True)
    note = models.ForeignKey(UserNote, on_delete=models.CASCADE, related_name='comments', verbose_name="Заметка", db_index=True)
    text = models.TextField(verbose_name="Текст комментария")
    moderation_status = models.CharField(
        max_length=50,
        choices=[('pending', 'Ожидает модерации'), ('approved', 'Одобрено'), ('rejected', 'Отклонено')],
        default='pending',
        verbose_name="Статус модерации",
        db_index=True
    )
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Комментарий"
        verbose_name_plural = "Комментарии"
        ordering = ['created_at']

    def __str__(self):
        return f"Комментарий от {self.user.username} к заметке {self.note.id}"

    # Ensure moderation status can be updated
    def can_moderate(self, user):
        return user.is_superuser or user.groups.filter(name='Moderators').exists()

backend\places\signals.py

# backend/places/signals.py

from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.db.models import Avg, Count
from places.models import Place, UserNote # Импортируем Place и UserNote

def recalculate_place_rating(place_id):
    """
    Пересчитывает средний рейтинг и количество оценок для указанного места.
    """
    place = Place.objects.get(id=place_id)
    
    # Фильтруем только заметки, которые одобрены и имеют оценку
    approved_notes_with_rating = UserNote.objects.filter(
        place=place,
        moderation_status='approved',
        rating__isnull=False
    )
    
    # Считаем средний рейтинг и количество оценок
    aggregation = approved_notes_with_rating.aggregate(
        avg_rating=Avg('rating'),
        count_rating=Count('id')
    )
    
    place.average_rating = aggregation['avg_rating'] if aggregation['avg_rating'] is not None else 0.0
    place.rating_count = aggregation['count_rating']
    place.save(update_fields=['average_rating', 'rating_count'])

@receiver(post_save, sender=UserNote)
def user_note_post_save(sender, instance, **kwargs):
    """
    Сигнал после сохранения заметки пользователя.
    Пересчитывает рейтинг места.
    """
    if instance.rating is not None and instance.moderation_status == 'approved':
        recalculate_place_rating(instance.place.id)

@receiver(post_delete, sender=UserNote)
def user_note_post_delete(sender, instance, **kwargs):
    """
    Сигнал после удаления заметки пользователя.
    Пересчитывает рейтинг места.
    """
    if instance.rating is not None and instance.moderation_status == 'approved':
        recalculate_place_rating(instance.place.id)

backend\places\urls.py

from rest_framework.routers import DefaultRouter
from places.api.viewsets import PlaceViewSet, UserNoteViewSet, CommentViewSet

router = DefaultRouter()
router.register(r'places', PlaceViewSet, basename='place')
router.register(r'notes', UserNoteViewSet, basename='usernote')
router.register(r'comments', CommentViewSet, basename='comment')

urlpatterns = router.urls

backend\places\__init__.py

# backend/places/__init__.py

default_app_config = 'places.apps.PlacesConfig'

backend\users\serializers.py

# backend/users/serializers.py
from rest_framework import serializers
from django.contrib.auth.models import User

class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ('id', 'username', 'email', 'password')
        extra_kwargs = {'password': {'write_only': True}}

    def create(self, validated_data):
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data.get('email', ''),
            password=validated_data['password']
        )
        return user

class AuthTokenSerializer(serializers.Serializer):
    username = serializers.CharField(label="Username", write_only=True)
    password = serializers.CharField(label="Password", style={'input_type': 'password'}, trim_whitespace=False, write_only=True)
    token = serializers.CharField(label="Token", read_only=True)

    def validate(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')

        if username and password:
            from django.contrib.auth import authenticate
            user = authenticate(request=self.context.get('request'), username=username, password=password)

            if not user:
                msg = 'Unable to log in with provided credentials.'
                raise serializers.ValidationError(msg, code='authorization')
        else:
            msg = 'Must include "username" and "password".'
            raise serializers.ValidationError(msg, code='authorization')

        attrs['user'] = user
        return attrs

backend\users\urls.py

# backend/users/urls.py

from django.urls import path
from .views import RegisterView, LoginView, LogoutView, UserProfileView

urlpatterns = [
    path('register/', RegisterView.as_view(), name='register'),
    path('login/', LoginView.as_view(), name='login'),
    path('logout/', LogoutView.as_view(), name='logout'),
    path('profile/', UserProfileView.as_view(), name='profile'),
]

backend\users\views.py

# backend/users/views.py
from rest_framework import generics, status
from rest_framework.response import Response
from rest_framework.authtoken.models import Token
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.views import APIView
from django.contrib.auth.models import User
from .serializers import UserSerializer, AuthTokenSerializer

class RegisterView(generics.CreateAPIView):
    queryset = User.objects.all()
    permission_classes = (AllowAny,)
    serializer_class = UserSerializer

    def perform_create(self, serializer):
        user = serializer.save()
        token, created = Token.objects.get_or_create(user=user)

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        if not serializer.is_valid():
            print("Validation errors:", serializer.errors)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        user = User.objects.get(username=serializer.data['username'])
        token = Token.objects.get(user=user).key
        return Response({
            'user_id': user.pk,
            'username': user.username,
            'email': user.email,
            'token': token
        }, status=status.HTTP_201_CREATED, headers=headers)

class LoginView(ObtainAuthToken):
    serializer_class = AuthTokenSerializer

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.validated_data['user']
        token, created = Token.objects.get_or_create(user=user)
        print(f"Login successful for {user.username}, token: {token.key}")  # Для отладки
        return Response({
            'token': token.key,
            'user_id': user.pk,
            'email': user.email,
            'username': user.username
        })
class LogoutView(APIView):
    permission_classes = (IsAuthenticated,)

    def post(self, request):
        try:
            request.user.auth_token.delete()
        except Token.DoesNotExist:
            pass
        return Response(status=status.HTTP_200_OK)

class UserProfileView(generics.RetrieveAPIView):
    permission_classes = (IsAuthenticated,)
    serializer_class = UserSerializer

    def get(self, request, *args, **kwargs):
        user = request.user
        serializer = self.get_serializer(user)
        data = serializer.data
        data['is_superuser'] = user.is_superuser
        data['groups'] = [group.name for group in user.groups.all()]
        return Response(data)

frontend\myths_legends_app\docker-compose.yml

version: "3.8"
services:
  app:
    build:
      context: .
    volumes:
      - .:/myths_legends_app
      - /myths_legends_app/node_modules
    ports:
      - 3000:3000
    image: app:react
    container_name: react_container
    command: npm start
    stdin_open: true
    tty: true
    environment:
      REACT_APP_API_BASE_URL: http://localhost:8000

frontend\myths_legends_app\public\index.html

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#000000" />
<meta
name="description"
content="Web site created using create-react-app"
/>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
href="https://fonts.googleapis.com/css2?family=Poppins&display=swap"
rel="stylesheet"
/>
<link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
<title>Путеводитель по мифам и легендам</title>
</head>
<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<div id="root"></div>
</body>
</html>



frontend\myths_legends_app\src\App.css

html, body {
  margin: 0px;
  padding: 0px;
  font-family: Poppins, sans-serif;
}








frontend\myths_legends_app\src\App.js

// frontend/myths_legends_app/src/App.js
import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import { AuthProvider } from './components/AuthContext';
import HomePage from './pages/HomePage';
import ProfilePage from './pages/ProfilePage';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import NavBar from './components/NavBar';
import ModerationPage from './pages/ModerationPage';

function App() {
  return (
    <Router>
      <AuthProvider>
        <NavBar />
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/profile" element={<ProfilePage />} />
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />
          <Route path="/moderation" element={<ModerationPage />} />
          <Route path="/map" element={<HomePage />} />
        </Routes>
      </AuthProvider>
    </Router>
  );
}

export default App;

frontend\myths_legends_app\src\components\AuthContext.js

// frontend/myths_legends_app/src/components/AuthContext.js
import React, { createContext, useState, useEffect, useContext } from 'react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

const AuthContext = createContext(null);

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL;

export const AuthProvider = ({ children }) => {
  const [authToken, setAuthToken] = useState(localStorage.getItem('authToken'));
  const [currentUser, setCurrentUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  axios.defaults.baseURL = API_BASE_URL;

  useEffect(() => {
    if (authToken) {
      axios.defaults.headers.common['Authorization'] = `Token ${authToken}`;
      fetchUserProfile();
    } else {
      delete axios.defaults.headers.common['Authorization'];
      setCurrentUser(null);
      setLoading(false);
    }
  }, [authToken]);

  const fetchUserProfile = async () => {
    try {
      const response = await axios.get('/api/auth/profile/');
      const { id, username, email, is_superuser, groups } = response.data;
      setCurrentUser({
        id,
        username,
        email,
        is_superuser,
        groups: groups || [],
      });
    } catch (error) {
      console.error('Failed to fetch user profile:', error.response?.data || error.message);
      setAuthToken(null);
      localStorage.removeItem('authToken');
      setCurrentUser(null);
    } finally {
      setLoading(false);
    }
  };

  const login = async (username, password) => {
    try {
      const response = await axios.post('/api/auth/login/', { username, password });
      const { token, user_id, email, username: userName } = response.data;
      localStorage.setItem('authToken', token);
      axios.defaults.headers.common['Authorization'] = `Token ${token}`;
      setAuthToken(token);
      await fetchUserProfile();
      navigate('/profile'); // Redirect to profile after login
      return true;
    } catch (error) {
      console.error('Login failed:', error.response?.data || error.message);
      alert('Login failed: ' + (error.response?.data?.detail || error.message));
      return false;
    }
  };

  const register = async (username, email, password) => {
    try {
      await axios.post('/api/auth/register/', { username, email, password });
      alert('Registration successful! Please log in.');
      return true;
    } catch (error) {
      console.error('Registration failed:', error.response?.data || error.message);
      alert('Registration failed: ' + (error.response?.data?.username?.[0] || error.response?.data?.email?.[0] || error.message));
      return false;
    }
  };

  const logout = async () => {
    try {
      await axios.post('/api/auth/logout/');
    } catch (error) {
      console.error('Logout failed:', error);
    } finally {
      setAuthToken(null);
      localStorage.removeItem('authToken');
      delete axios.defaults.headers.common['Authorization'];
      setCurrentUser(null);
      navigate('/'); // Redirect to homepage after logout
    }
  };

  const value = {
    authToken,
    currentUser,
    isLoggedIn: !!authToken,
    isModeratorOrAdmin: currentUser && (currentUser.is_superuser || currentUser.groups.includes('Moderators')),
    loading,
    login,
    register,
    logout,
    fetchUserProfile,
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  return useContext(AuthContext);
};

frontend\myths_legends_app\src\components\NavBar.js

// frontend/myths_legends_app/src/components/NavBar.js
import React from 'react';
import { useAuth } from './AuthContext';
import { useNavigate } from 'react-router-dom';

function NavBar() {
  const { isLoggedIn, currentUser, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = async () => {
    await logout();
  };

  return (
    <nav style={{ background: '#333', color: 'white', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
      <div>
        <a href="/" style={{ color: 'white', marginRight: '20px', textDecoration: 'none' }}>Myths and Legends</a>
      </div>
      <div>
        {isLoggedIn && currentUser ? (
          <>
            <span style={{ marginRight: '20px' }}>
              {currentUser.username} ({currentUser.is_superuser ? 'Admin' : currentUser.groups.includes('Moderators') ? 'Moderator' : 'User'})
            </span>
            <button onClick={() => navigate('/profile')} style={{ marginRight: '10px' }}>Profile</button>
            {currentUser.is_superuser && (
              <button onClick={() => navigate('/moderation')} style={{ marginRight: '10px' }}>Moderation</button>
            )}
            <button onClick={handleLogout} style={{ marginRight: '10px' }}>Logout</button>
          </>
        ) : (
          <>
            <button onClick={() => navigate('/login')} style={{ marginRight: '10px' }}>Login</button>
            <button onClick={() => navigate('/register')}>Register</button>
          </>
        )}
      </div>
    </nav>
  );
}

export default NavBar;

frontend\myths_legends_app\src\index.css

body {

margin: 0;

font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',

'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',

sans-serif;

-webkit-font-smoothing: antialiased;

-moz-osx-font-smoothing: grayscale;

}



code {

font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',

monospace;

}

frontend\myths_legends_app\src\index.js

// frontend/myths_legends_app/src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css'; // If you have global styles

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

frontend\myths_legends_app\src\pages\HomePage.js

import React, { useEffect, useState, useCallback } from "react";
import { MapContainer, TileLayer, Marker, Popup, useMapEvents, useMap } from "react-leaflet";
import { Icon } from "leaflet";
import axios from 'axios';
import L from 'leaflet';
import iconRetinaUrl from 'leaflet/dist/images/marker-icon-2x.png';
import iconUrl from 'leaflet/dist/images/marker-icon.png';
import shadowUrl from 'leaflet/dist/images/marker-shadow.png';
import 'leaflet/dist/leaflet.css'; // Ensure Leaflet CSS is imported

delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: iconRetinaUrl,
  iconUrl: iconUrl,
  shadowUrl: shadowUrl,
});

const customMarkerIcon = new Icon({
  iconUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png",
  shadowUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png",
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const userLocationIcon = new Icon({
  iconUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png",
  shadowUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png",
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const parseWktPoint = (wktString) => {
  if (!wktString || typeof wktString !== 'string') {
    return null;
  }
  const match = wktString.match(/POINT \(([^ ]+) ([^ ]+)\)/);
  if (match && match.length === 3) {
    const longitude = parseFloat(match[1]);
    const latitude = parseFloat(match[2]);
    if (!isNaN(longitude) && !isNaN(latitude)) {
      return { longitude, latitude };
    }
  }
  return null;
};

function LocationMarker({ position }) {
  const map = useMap();

  useEffect(() => {
    if (position) {
      map.flyTo(position, map.getZoom());
    }
  }, [position, map]);

  return position === null ? null : (
    <Marker position={position} icon={userLocationIcon}>
      <Popup>Вы находитесь здесь!</Popup>
    </Marker>
  );
}

function MapEventsHandler({ onLocateMe }) {
  const map = useMapEvents({});
  return (
    <div style={{
      position: 'absolute',
      bottom: '20px',
      right: '20px',
      zIndex: 1000
    }}>
      <button
        onClick={() => onLocateMe(map)}
        style={{
          width: '50px',
          height: '50px',
          borderRadius: '50%',
          backgroundColor: '#007bff',
          color: 'white',
          fontSize: '24px',
          border: 'none',
          cursor: 'pointer',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          boxShadow: '0 2px 5px rgba(0,0,0,0.2)'
        }}
        title="Моя геолокация"
      >
        📍
      </button>
    </div>
  );
}

function HomePage() {
  console.log("HomePage is rendering!");

  const [places, setPlaces] = useState([]);
  const [userLocation, setUserLocation] = useState(null);

  const kazanCoordinates = [55.7961, 49.1064];
  const initialZoom = 15;
  const radiusKm = 2;

  const fetchPlaces = useCallback(async (latitude = null, longitude = null) => {
    let url = `${process.env.REACT_APP_API_BASE_URL}/api/places/`;
    if (latitude !== null && longitude !== null) {
      url = `${process.env.REACT_APP_API_BASE_URL}/api/places/nearest/?lat=${latitude}&lon=${longitude}&radius_km=${radiusKm}`;
    }

    try {
      const response = await axios.get(url);
      if (response.status !== 200) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = response.data;
      if (data && data.type === 'FeatureCollection' && Array.isArray(data.features)) {
        setPlaces(data.features);
      } else {
        console.error("API response is not a valid GeoJSON FeatureCollection:", data);
        setPlaces([]);
      }
    } catch (error) {
      console.error("Error fetching places:", error);
      setPlaces([]);
    }
  }, [radiusKm]);

  useEffect(() => {
    fetchPlaces();
  }, [fetchPlaces]);

  const handleLocateMe = useCallback((mapInstance) => {
    if ("geolocation" in navigator) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const { latitude, longitude } = position.coords;
          const currentLatLng = L.latLng(latitude, longitude);
          setUserLocation(currentLatLng);
          mapInstance.flyTo(currentLatLng, mapInstance.getZoom());
          fetchPlaces(latitude, longitude);
        },
        (error) => {
          console.error("Error getting user location:", error);
          alert("Не удалось определить вашу геолокацию. Возможно, вы запретили доступ или функция недоступна.");
          fetchPlaces();
        },
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
      );
    } else {
      alert("Ваш браузер не поддерживает геолокацию.");
      fetchPlaces();
    }
  }, [fetchPlaces]);

  return (
    <div className="main">
      <MapContainer
        center={kazanCoordinates}
        zoom={initialZoom}
        scrollWheelZoom={true}
        style={{ height: 'calc(100vh - 80px)', width: '100%' }} // Removed backgroundColor for debugging
      >
        <TileLayer
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        />
        <LocationMarker position={userLocation} />
        <MapEventsHandler onLocateMe={handleLocateMe} />
        {places.map(place => {
          const coords = parseWktPoint(place.geometry);
          if (!coords) {
            console.warn("Пропускаем место из-за отсутствующих или некорректных координат (WKT):", place);
            return null;
          }
          const distanceInfo = place.properties.distance !== null && place.properties.distance !== undefined
            ? `<br/>Расстояние: ${place.properties.distance.toFixed()} метров`
            : '';
          return (
            <Marker
              position={[coords.latitude, coords.longitude]}
              icon={customMarkerIcon}
              key={place.id || place.properties.id}
            >
              <Popup>
                <b>{place.properties.name}</b><br />
                {place.properties.description}
                {distanceInfo}
                {place.properties.image && (
                  <img
                    src={place.properties.image}
                    alt={place.properties.name}
                    style={{ maxWidth: '100px', maxHeight: '100px', marginTop: '5px' }}
                  />
                )}
                <p>Категории: {place.properties.categories}</p>
                <p>Рейтинг: {place.properties.avg_rating ? place.properties.avg_rating.toFixed(1) : 'Нет'}</p>
                <p>Заметок: {place.properties.notes_count}</p>
              </Popup>
            </Marker>
          );
        })}
      </MapContainer>
    </div>
  );
}

export default HomePage;

frontend\myths_legends_app\src\pages\LoginPage.css

.login-container {
  max-width: 400px;
  margin: 50px auto;
  padding: 20px;
  border: 1px solid #ccc;
  border-radius: 5px;
  text-align: center;
}

.login-container div {
  margin-bottom: 15px;
}

.login-container label {
  display: block;
  margin-bottom: 5px;
}

.login-container input {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.login-container button {
  padding: 10px 20px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.login-container button:hover {
  background-color: #0056b3;
}

.login-container a {
  color: #007bff;
  text-decoration: none;
}

.login-container a:hover {
  text-decoration: underline;
}

frontend\myths_legends_app\src\pages\LoginPage.js

// frontend/myths_legends_app/src/pages/LoginPage.js
import React, { useState } from 'react';
import { useAuth } from '../components/AuthContext';
import { useNavigate } from 'react-router-dom';
import './LoginPage.css';

function LoginPage() {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [credentials, setCredentials] = useState({ username: '', password: '' });
  const [error, setError] = useState('');

  const handleChange = (e) => {
    setCredentials({ ...credentials, [e.target.name]: e.target.value });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    const success = await login(credentials.username, credentials.password);
    if (success) {
      navigate('/');
    } else {
      setError('Неверное имя пользователя или пароль.');
    }
  };

  return (
    <div className="login-container">
      <h2>Вход в систему</h2>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <form onSubmit={handleSubmit}>
        <div>
          <label>Имя пользователя:</label>
          <input
            type="text"
            name="username"
            value={credentials.username}
            onChange={handleChange}
            required
          />
        </div>
        <div>
          <label>Пароль:</label>
          <input
            type="password"
            name="password"
            value={credentials.password}
            onChange={handleChange}
            required
          />
        </div>
        <button type="submit">Войти</button>
      </form>
      <p>
        Нет аккаунта? <a href="/register">Зарегистрироваться</a>
      </p>
    </div>
  );
}

export default LoginPage;

frontend\myths_legends_app\src\pages\ModerationPage.css

/* frontend/myths_legends_app/src/pages/ModerationPage.css */
.moderation-container {
  padding: 20px;
  max-width: 800px;
  margin: 0 auto;
}

.moderation-list {
  list-style: none;
  padding: 0;
}

.moderation-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  border-bottom: 1px solid #ddd;
  margin-bottom: 10px;
}

.moderation-item div {
  flex: 1;
}

button {
  padding: 5px 10px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  opacity: 0.9;
}

.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: white;
  padding: 20px;
  border-radius: 5px;
  max-width: 500px;
  width: 90%;
  position: relative;
}

.modal-content button {
  margin-top: 10px;
}

frontend\myths_legends_app\src\pages\ModerationPage.js

// frontend/myths_legends_app/src/pages/ModerationPage.js
import React, { useEffect, useState } from 'react';
import { useAuth } from '../components/AuthContext';
import axios from 'axios';
import './ModerationPage.css';

function ModerationPage() {
  const { isLoggedIn, currentUser, isModeratorOrAdmin } = useAuth();
  const [pendingItems, setPendingItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [selectedItem, setSelectedItem] = useState(null);

  useEffect(() => {
    if (!isLoggedIn || !isModeratorOrAdmin) {
      setError('Доступ запрещён. Только модераторы и администраторы могут просматривать эту страницу.');
      setLoading(false);
      return;
    }

    const fetchPendingItems = async () => {
      try {
        const headers = { Authorization: `Token ${localStorage.getItem('authToken')}` };
        const [placesResponse, notesResponse, commentsResponse] = await Promise.all([
          axios.get(`${process.env.REACT_APP_API_BASE_URL}/api/places/?moderation_status=pending`, { headers }),
          axios.get(`${process.env.REACT_APP_API_BASE_URL}/api/notes/?moderation_status=pending`, { headers }),
          axios.get(`${process.env.REACT_APP_API_BASE_URL}/api/comments/?moderation_status=pending`, { headers }),
        ]);

        const places = placesResponse.data.features || placesResponse.data.results || [];
        const notes = notesResponse.data.results || notesResponse.data || [];
        const comments = commentsResponse.data.results || commentsResponse.data || [];

        // Ensure user object has groups property
        setPendingItems([
          ...places.map(item => ({
            ...item,
            type: 'place',
            user: {
              ...item.owner,
              username: item.owner?.username || 'Unknown',
              is_superuser: item.owner?.is_superuser || false,
              groups: item.owner?.groups || []
            }
          })),
          ...notes.map(item => ({
            ...item,
            type: 'note',
            user: {
              ...item.user,
              username: item.user?.username || 'Unknown',
              is_superuser: item.user?.is_superuser || false,
              groups: item.user?.groups || []
            }
          })),
          ...comments.map(item => ({
            ...item,
            type: 'comment',
            user: {
              ...item.user,
              username: item.user?.username || 'Unknown',
              is_superuser: item.user?.is_superuser || false,
              groups: item.user?.groups || []
            }
          })),
        ]);
        setLoading(false);
      } catch (err) {
        console.error('Error fetching pending items:', err.response?.data || err.message);
        setError('Не удалось загрузить данные для модерации. Проверьте подключение или обратитесь к администратору. Ошибка: ' + (err.response?.statusText || err.message));
        setLoading(false);
      }
    };

    fetchPendingItems();
  }, [isLoggedIn, isModeratorOrAdmin]);

  const handleModeration = async (itemId, type, action) => {
    try {
      const headers = { Authorization: `Token ${localStorage.getItem('authToken')}` };
      let url;
      switch (type) {
        case 'place':
          url = `${process.env.REACT_APP_API_BASE_URL}/api/places/${itemId}/${action === 'approve' ? 'approve' : 'reject'}/`;
          break;
        case 'note':
          url = `${process.env.REACT_APP_API_BASE_URL}/api/notes/${itemId}/${action === 'approve' ? 'approve' : 'reject'}/`;
          break;
        case 'comment':
          url = `${process.env.REACT_APP_API_BASE_URL}/api/comments/${itemId}/${action === 'approve' ? 'approve' : 'reject'}/`;
          break;
        default:
          throw new Error('Неверный тип элемента');
      }

      await axios.patch(url, {}, { headers }); // Empty body since action is in URL
      setPendingItems(prevItems => prevItems.filter(item => item.id !== itemId));
      alert(`${type === 'place' ? 'Место' : type === 'note' ? 'Заметка' : 'Комментарий'} успешно ${action === 'approve' ? 'одобрено' : 'отклонено'}.`);
      setSelectedItem(null); // Close popup after action
    } catch (err) {
      console.error('Error moderating item:', err.response?.data || err.message);
      alert('Ошибка при модерации. Попробуйте снова. Ошибка: ' + (err.response?.data?.detail || err.message));
    }
  };

  const openPopup = (item) => {
    setSelectedItem(item);
  };

  const closePopup = () => {
    setSelectedItem(null);
  };

  if (loading) return <div style={{ textAlign: 'center', padding: '20px' }}>Загрузка...</div>;
  if (error) return <div style={{ color: 'red', textAlign: 'center', padding: '20px' }}>{error}</div>;
  if (!isLoggedIn || !isModeratorOrAdmin) return null;

  return (
    <div className="moderation-container">
      <h2>Панель модерации</h2>
      {pendingItems.length === 0 ? (
        <p>Нет элементов, требующих модерации.</p>
      ) : (
        <ul className="moderation-list">
          {pendingItems.map(item => (
            <li key={`${item.type}-${item.id}`} className="moderation-item">
              <div>
                <strong>{item.type === 'place' ? 'Место' : item.type === 'note' ? 'Заметка' : 'Комментарий'}: </strong>
                {item.type === 'place' ? item.properties?.name || item.name : item.text || item.content}
                <br />
                <small>Автор: {item.user.username} ({item.user.is_superuser ? 'Admin' : item.user.groups.includes('Moderators') ? 'Moderator' : 'User'})</small>
              </div>
              <div>
                <button
                  onClick={() => openPopup(item)}
                  style={{ marginRight: '10px', backgroundColor: '#007bff', color: 'white' }}
                >
                  Просмотреть
                </button>
                <button
                  onClick={() => handleModeration(item.id, item.type, 'approve')}
                  style={{ marginRight: '10px', backgroundColor: '#28a745', color: 'white' }}
                >
                  Одобрить
                </button>
                <button
                  onClick={() => handleModeration(item.id, item.type, 'reject')}
                  style={{ backgroundColor: '#dc3545', color: 'white' }}
                >
                  Отклонить
                </button>
              </div>
            </li>
          ))}
        </ul>
      )}

      {selectedItem && (
        <div className="modal" onClick={closePopup}>
          <div className="modal-content" onClick={e => e.stopPropagation()}>
            <h3>{selectedItem.type === 'place' ? 'Место' : selectedItem.type === 'note' ? 'Заметка' : 'Комментарий'}</h3>
            <p><strong>Название:</strong> {selectedItem.type === 'place' ? selectedItem.properties?.name || selectedItem.name : selectedItem.text || selectedItem.content}</p>
            {selectedItem.type === 'place' && selectedItem.properties?.description && (
              <p><strong>Описание:</strong> {selectedItem.properties.description}</p>
            )}
            {selectedItem.type === 'note' && selectedItem.text && (
              <p><strong>Текст:</strong> {selectedItem.text}</p>
            )}
            {selectedItem.type === 'comment' && selectedItem.content && (
              <p><strong>Текст:</strong> {selectedItem.content}</p>
            )}
            <p><strong>Автор:</strong> {selectedItem.user.username} ({selectedItem.user.is_superuser ? 'Admin' : selectedItem.user.groups.includes('Moderators') ? 'Moderator' : 'User'})</p>
            <button onClick={() => handleModeration(selectedItem.id, selectedItem.type, 'approve')} style={{ backgroundColor: '#28a745', color: 'white' }}>Одобрить</button>
            <button onClick={() => handleModeration(selectedItem.id, selectedItem.type, 'reject')} style={{ backgroundColor: '#dc3545', color: 'white', marginLeft: '10px' }}>Отклонить</button>
            <button onClick={closePopup} style={{ backgroundColor: '#6c757d', color: 'white', marginLeft: '10px' }}>Закрыть</button>
          </div>
        </div>
      )}
    </div>
  );
}

export default ModerationPage;

frontend\myths_legends_app\src\pages\ProfilePage.css

/* frontend/myths_legends_app/src/pages/ProfilePage.css */
.profile-container {
  max-width: 800px;
  margin: 50px auto;
  padding: 20px;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.profile-info {
  margin-bottom: 20px;
  padding: 15px;
  background-color: #f8f9fa;
  border-radius: 8px;
}

.profile-info p {
  margin: 8px 0;
  font-size: 16px;
}

.profile-section {
  margin-bottom: 20px;
}

.profile-section h3 {
  margin: 0 0 10px;
  color: #333;
  font-size: 20px;
}

.profile-section ul {
  list-style-type: none;
  padding: 0;
}

.profile-section li {
  padding: 10px 0;
  border-bottom: 1px solid #eee;
  font-size: 14px;
}

.logout-button {
  padding: 10px 20px;
  background-color: #dc3545;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
}

.logout-button:hover {
  background-color: #c82333;
}

frontend\myths_legends_app\src\pages\ProfilePage.js

// frontend/myths_legends_app/src/pages/ProfilePage.js
import React, { useEffect, useState } from 'react';
import { useAuth } from '../components/AuthContext';
import { useNavigate } from 'react-router-dom';
import axios from 'axios';
import './ProfilePage.css';

function ProfilePage() {
  const { currentUser, isLoggedIn, logout } = useAuth();
  const navigate = useNavigate();
  const [userPlaces, setUserPlaces] = useState([]);
  const [userNotes, setUserNotes] = useState([]);
  const [favoritePlaces, setFavoritePlaces] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!isLoggedIn) {
      navigate('/login');
      return;
    }
    if (!currentUser) {
      console.log('Current user not loaded yet, waiting...');
      return;
    }

    const fetchUserData = async () => {
      try {
        const headers = { Authorization: `Token ${localStorage.getItem('authToken')}` };

        const placesResponse = await axios.get(`${process.env.REACT_APP_API_BASE_URL}/api/places/?owner=${currentUser.id}`, { headers });
        const placesData = placesResponse.data.features || placesResponse.data.results || placesResponse.data;
        setUserPlaces(Array.isArray(placesData) ? placesData : []);

        const notesResponse = await axios.get(`${process.env.REACT_APP_API_BASE_URL}/api/notes/?user=${currentUser.id}`, { headers });
        const notesData = notesResponse.data.results || notesResponse.data;
        setUserNotes(Array.isArray(notesData) ? notesData : []);

        const favoritesResponse = await axios.get(`${process.env.REACT_APP_API_BASE_URL}/api/places/`, { headers });
        const allPlaces = favoritesResponse.data.features || favoritesResponse.data.results || favoritesResponse.data;
        const userFavorites = allPlaces.filter(place =>
          place.favorites && place.favorites.some(fav => fav === currentUser.id)
        );
        setFavoritePlaces(userFavorites);

        setLoading(false);
      } catch (err) {
        console.error('Error fetching user data:', err.response?.data || err.message);
        setError('Не удалось загрузить данные профиля. Проверьте подключение или обратитесь к администратору.');
        setLoading(false);
      }
    };

    fetchUserData();
  }, [isLoggedIn, currentUser, navigate]);

  const handleLogout = async () => {
    await logout();
  };

  if (loading) return <div style={{ textAlign: 'center', padding: '20px' }}>Загрузка...</div>;
  if (error) return <div style={{ color: 'red', textAlign: 'center', padding: '20px' }}>{error}</div>;
  if (!isLoggedIn || !currentUser) return <div style={{ textAlign: 'center', padding: '20px' }}>Пожалуйста, войдите в систему.</div>;

  const role = currentUser.is_superuser ? 'Администратор' : currentUser.groups.includes('Moderators') ? 'Модератор' : 'Пользователь';

  return (
    <div className="profile-container">
      <div style={{ background: '#333', color: 'white', padding: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <button onClick={() => navigate('/map')} style={{ marginRight: '10px' }}>Карта</button>
        <button onClick={handleLogout}>Выход</button>
        {currentUser.is_superuser && <button onClick={() => navigate('/moderation')} style={{ marginLeft: '10px' }}>Модерация</button>}
      </div>
      <h2>Профиль пользователя</h2>
      <div className="profile-info">
        <p><strong>Имя пользователя:</strong> {currentUser.username}</p>
        <p><strong>Email:</strong> {currentUser.email || 'Не указан'}</p>
        <p><strong>Роль:</strong> {role}</p>
      </div>

      <div className="profile-section">
        <h3>Ваши места ({userPlaces.length})</h3>
        {userPlaces.length > 0 ? (
          <ul>
            {userPlaces.map(place => (
              <li key={place.id}>
                {place.properties?.name || place.name} (Статус: {place.properties?.status || place.status})
              </li>
            ))}
          </ul>
        ) : (
          <p>Вы еще не добавили ни одного места.</p>
        )}
      </div>

      <div className="profile-section">
        <h3>Ваши заметки ({userNotes.length})</h3>
        {userNotes.length > 0 ? (
          <ul>
            {userNotes.map(note => (
              <li key={note.id}>
                {note.text} (Место: {note.place?.name || 'Неизвестно'}, Статус: {note.moderation_status})
              </li>
            ))}
          </ul>
        ) : (
          <p>Вы еще не оставили ни одной заметки.</p>
        )}
      </div>

      <div className="profile-section">
        <h3>Избранные места ({favoritePlaces.length})</h3>
        {favoritePlaces.length > 0 ? (
          <ul>
            {favoritePlaces.map(place => (
              <li key={place.id}>
                {place.properties?.name || place.name}
              </li>
            ))}
          </ul>
        ) : (
          <p>У вас нет избранных мест.</p>
        )}
      </div>
    </div>
  );
}

export default ProfilePage;

frontend\myths_legends_app\src\pages\RegisterPage.css

.register-container {
  max-width: 400px;
  margin: 50px auto;
  padding: 20px;
  border: 1px solid #ccc;
  border-radius: 5px;
  text-align: center;
}

.register-container div {
  margin-bottom: 15px;
}

.register-container label {
  display: block;
  margin-bottom: 5px;
}

.register-container input {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.register-container button {
  padding: 10px 20px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.register-container button:hover {
  background-color: #218838;
}

.register-container a {
  color: #007bff;
  text-decoration: none;
}

.register-container a:hover {
  text-decoration: underline;
}

frontend\myths_legends_app\src\pages\RegisterPage.js

// frontend/myths_legends_app/src/pages/RegisterPage.js
import React, { useState } from 'react';
import { useAuth } from '../components/AuthContext';
import { useNavigate } from 'react-router-dom';
import './RegisterPage.css';

function RegisterPage() {
  const { register } = useAuth();
  const navigate = useNavigate();
  const [userData, setUserData] = useState({ username: '', email: '', password: '' });
  const [error, setError] = useState('');

  const handleChange = (e) => {
    setUserData({ ...userData, [e.target.name]: e.target.value });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    const success = await register(userData.username, userData.email, userData.password);
    if (success) {
      navigate('/login');
    } else {
      setError('Регистрация не удалась. Проверьте данные.');
    }
  };

  return (
    <div className="register-container">
      <h2>Регистрация</h2>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <form onSubmit={handleSubmit}>
        <div>
          <label>Имя пользователя:</label>
          <input
            type="text"
            name="username"
            value={userData.username}
            onChange={handleChange}
            required
          />
        </div>
        <div>
          <label>Email:</label>
          <input
            type="email"
            name="email"
            value={userData.email}
            onChange={handleChange}
            required
          />
        </div>
        <div>
          <label>Пароль:</label>
          <input
            type="password"
            name="password"
            value={userData.password}
            onChange={handleChange}
            required
          />
        </div>
        <button type="submit">Зарегистрироваться</button>
      </form>
      <p>
        Уже есть аккаунт? <a href="/login">Войти</a>
      </p>
    </div>
  );
}

export default RegisterPage;

