frontend\myths_legends_app\docker-compose.yml

version: "3.8"
services:
  app:
    build:
      context: .
    volumes:
      - .:/myths_legends_app
      - /myths_legends_app/node_modules
    ports:
      - 3000:3000
    image: app:react
    container_name: react_container
    command: npm start
    stdin_open: true
    tty: true
    environment:
      REACT_APP_API_BASE_URL: http://localhost:8000

frontend\myths_legends_app\public\index.html

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#000000" />
<meta
name="description"
content="Web site created using create-react-app"
/>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
href="https://fonts.googleapis.com/css2?family=Poppins&display=swap"
rel="stylesheet"
/>
<link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
<title>–ü—É—Ç–µ–≤–æ–¥–∏—Ç–µ–ª—å –ø–æ –º–∏—Ñ–∞–º –∏ –ª–µ–≥–µ–Ω–¥–∞–º</title>
</head>
<body>
<noscript>You need to enable JavaScript to run this app.</noscript>
<div id="root"></div>
</body>
</html>



frontend\myths_legends_app\src\App.css

html, body {
  margin: 0px;
  padding: 0px;
  font-family: Poppins, sans-serif;
}

/* –≠—Ç–æ –ø—Ä–∞–≤–∏–ª–æ —Ç–µ–ø–µ—Ä—å –Ω–µ –Ω—É–∂–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –≤—ã—Å–æ—Ç–∞ –∫–∞—Ä—Ç—ã —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ Flexbox –≤ Layout –∏ –∏–Ω–ª–∞–π–Ω–æ–≤—ã–º–∏ —Å—Ç–∏–ª—è–º–∏ –≤ HomePage */
/* .leaflet-container {
  height: 100vh;
  width: 100%;
} */

/* –≠—Ç–æ—Ç –±–ª–æ–∫ CSS –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω, —Ç–∞–∫ –∫–∞–∫ div.main —É–¥–∞–ª–µ–Ω –∏–∑ HomePage.js */
/* .main {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  flex-direction: column;
} */


frontend\myths_legends_app\src\App.js

import "./App.css";
import "leaflet/dist/leaflet.css"; // –°—Ç–∏–ª–∏ Leaflet –≤—Å–µ –µ—â–µ –Ω—É–∂–Ω—ã –≥–ª–æ–±–∞–ª—å–Ω–æ
import React from "react";
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

// –ò–º–ø–æ—Ä—Ç—ã –¥–ª—è AuthProvider –∏ Layout
import { AuthProvider } from './components/AuthContext';
import Layout from './components/Layout';

// –ò–º–ø–æ—Ä—Ç—ã –∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –∏–∫–æ–Ω–æ–∫ Leaflet –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
import L from 'leaflet';
import iconRetinaUrl from 'leaflet/dist/images/marker-icon-2x.png';
import iconUrl from 'leaflet/dist/images/marker-icon.png';
import shadowUrl from 'leaflet/dist/images/marker-shadow.png';

// –ò–º–ø–æ—Ä—Ç —Å—Ç—Ä–∞–Ω–∏—Ü - —Ç–æ–ª—å–∫–æ HomePage —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω
import HomePage from './pages/HomePage.js';
// import LoginPage from './pages/LoginPage';
// import RegisterPage from './pages/RegisterPage';
// import ProfilePage from './pages/ProfilePage';
// import PlacesListPage from './pages/PlacesListPage';
// import AddEditPlacePage from './pages/AddEditPlacePage';
// import AddEditNotePage from './pages/AddEditNotePage';
// import ModerationPage from './pages/ModerationPage'; 

delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
    iconRetinaUrl,
    iconUrl,
    shadowUrl,
});


function App() {
  return (
    <Router>
      <AuthProvider>
        <Layout>
          <Routes>
            <Route path="/" element={<HomePage />} />
            {/* –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã, –ø–æ–∫–∞ –Ω–µ –±—É–¥—É—Ç –≥–æ—Ç–æ–≤—ã */}
            {/* <Route path="/login" element={<LoginPage />} /> */}
            {/* <Route path="/register" element={<RegisterPage />} /> */}
            {/* <Route path="/profile" element={<ProfilePage />} /> */}
            {/* <Route path="/places" element={<PlacesListPage />} /> */}
            {/* <Route path="/places/add" element={<AddEditPlacePage />} /> */}
            {/* <Route path="/places/:id/edit" element={<AddEditPlacePage />} /> */}
            {/* <Route path="/places/:placeId/add-note" element={<AddEditNotePage />} /> */}
            {/* <Route path="/notes/:noteId/edit" element={<AddEditNotePage />} /> */}
            {/* <Route path="/moderation" element={<ModerationPage />} /> */}
          </Routes>
        </Layout>
      </AuthProvider>
    </Router>
  );
}

export default App;


frontend\myths_legends_app\src\components\AuthContext.js

import React, { createContext, useState, useEffect, useContext } from 'react';
import axios from 'axios';

const AuthContext = createContext(null);

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL;

export const AuthProvider = ({ children }) => {
  const [authToken, setAuthToken] = useState(localStorage.getItem('authToken'));
  const [currentUser, setCurrentUser] = useState(null);
  const [loading, setLoading] = useState(true);

  axios.defaults.baseURL = API_BASE_URL;

  useEffect(() => {
    if (authToken) {
      axios.defaults.headers.common['Authorization'] = `Token ${authToken}`;
      fetchUserProfile();
    } else {
      delete axios.defaults.headers.common['Authorization'];
      setCurrentUser(null);
      setLoading(false);
    }
  }, [authToken]);

  const fetchUserProfile = async () => {
    try {
      const response = await axios.get('/api/auth/profile/');
      setCurrentUser(response.data);
    } catch (error) {
      console.error('Failed to fetch user profile:', error);
      setAuthToken(null);
      localStorage.removeItem('authToken');
      setCurrentUser(null);
    } finally {
      setLoading(false);
    }
  };

  const login = async (username, password) => {
    try {
      const response = await axios.post('/api/auth/login/', { username, password });
      const token = response.data.token;
      setAuthToken(token);
      localStorage.setItem('authToken', token);
      return true;
    } catch (error) {
      console.error('Login failed:', error);
      alert('Login failed: ' + (error.response?.data?.detail || error.message));
      return false;
    }
  };

  const register = async (username, email, password) => {
    try {
      await axios.post('/api/auth/register/', { username, email, password });
      alert('Registration successful! Please log in.');
      return true;
    } catch (error) {
      console.error('Registration failed:', error);
      alert('Registration failed: ' + (error.response?.data?.username || error.response?.data?.email || error.message));
      return false;
    }
  };

  const logout = async () => {
    try {
      await axios.post('/api/auth/logout/');
    } catch (error) {
      console.error('Logout failed:', error);
    } finally {
      setAuthToken(null);
      localStorage.removeItem('authToken');
      setCurrentUser(null);
    }
  };

  const value = {
    authToken,
    currentUser,
    isLoggedIn: !!authToken,
    loading,
    login,
    register,
    logout,
    fetchUserProfile
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  return useContext(AuthContext);
};


frontend\myths_legends_app\src\components\Layout.js

import React from 'react';
import { Link, Outlet } from 'react-router-dom';
import { useAuth } from './AuthContext';

function Layout() {
  const { isLoggedIn, currentUser, logout } = useAuth();

  const handleLogout = async () => {
    await logout();
  };

  const isModeratorOrAdmin = currentUser && (currentUser.is_superuser || currentUser.groups.some(group => group.name === 'Moderators'));

  return (
    // –ö–æ—Ä–Ω–µ–≤–æ–π div —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è Flex-–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–º, –∑–∞–Ω–∏–º–∞—é—â–∏–º –≤—Å—é –≤—ã—Å–æ—Ç—É viewport
    <div style={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
      <header style={{ flexShrink: 0, padding: '10px 20px', borderBottom: '1px solid #ccc', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <h1 style={{ margin: 0, fontSize: '24px' }}>
          <Link to="/" style={{ textDecoration: 'none', color: 'inherit' }}>–ü—É—Ç–µ–≤–æ–¥–∏—Ç–µ–ª—å –ø–æ –º–∏—Ñ–∞–º</Link>
        </h1>
        <nav>
          <ul style={{ listStyle: 'none', margin: 0, padding: 0, display: 'flex', gap: '15px' }}>
            <li>
              <Link to="/" style={{ textDecoration: 'none', color: 'blue' }}>–ö–∞—Ä—Ç–∞</Link>
            </li>
            <li>
              <Link to="/places" style={{ textDecoration: 'none', color: 'blue' }}>–°–ø–∏—Å–æ–∫ –ú–µ—Å—Ç</Link>
            </li>
            {isModeratorOrAdmin && (
              <li>
                <Link to="/moderation" style={{ textDecoration: 'none', color: 'orange' }}>–ú–æ–¥–µ—Ä–∞—Ü–∏—è</Link>
              </li>
            )}
            <li>
              {isLoggedIn ? (
                <>
                  <Link to="/profile" style={{ textDecoration: 'none', color: 'blue' }}>–ü—Ä–æ—Ñ–∏–ª—å ({currentUser.username})</Link>
                  <button onClick={handleLogout} style={{ marginLeft: '10px', background: 'none', border: '1px solid red', color: 'red', cursor: 'pointer', padding: '5px 10px', borderRadius: '5px' }}>–í—ã–π—Ç–∏</button>
                </>
              ) : (
                <Link to="/login" style={{ textDecoration: 'none', color: 'blue' }}>–í–æ–π—Ç–∏</Link>
              )}
            </li>
          </ul>
        </nav>
      </header>
      {/* –≠–ª–µ–º–µ–Ω—Ç main –∑–∞–Ω–∏–º–∞–µ—Ç –≤—Å–µ –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –ø–æ –≤—ã—Å–æ—Ç–µ */}
      {/* –£–±–∏—Ä–∞–µ–º padding –æ—Ç—Å—é–¥–∞, —á—Ç–æ–±—ã –∫–∞—Ä—Ç–∞ –º–æ–≥–ª–∞ –∑–∞–Ω–∏–º–∞—Ç—å 100% –¥–æ—Å—Ç—É–ø–Ω–æ–π –≤—ã—Å–æ—Ç—ã */}
      <main style={{ flexGrow: 1, padding: '0px', overflowY: 'auto' }}>
        <Outlet />
      </main>
    </div>
  );
}

export default Layout;


frontend\myths_legends_app\src\index.css

body {

margin: 0;

font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',

'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',

sans-serif;

-webkit-font-smoothing: antialiased;

-moz-osx-font-smoothing: grayscale;

}



code {

font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',

monospace;

}

frontend\myths_legends_app\src\index.js

import React from 'react';

import ReactDOM from 'react-dom/client';

import './index.css';

import App from './App';



const root = ReactDOM.createRoot(document.getElementById('root'));

root.render(

<React.StrictMode>

<App />

</React.StrictMode>

);

frontend\myths_legends_app\src\pages\HomePage.js

import React, { useEffect, useState, useCallback } from "react";
import { MapContainer, TileLayer, Marker, Popup, useMapEvents, useMap } from "react-leaflet";
import { Icon } from "leaflet";
import axios from 'axios';
import L from 'leaflet';

// –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–∫–æ–Ω–æ–∫ Leaflet –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–æ—Å—Ç–∞–≤–ª—è–µ–º –∑–¥–µ—Å—å, –µ—Å–ª–∏ App.js –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç)
// –ï—Å–ª–∏ App.js —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —ç—Ç–æ—Ç –±–ª–æ–∫, –µ–≥–æ –º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –æ—Ç—Å—é–¥–∞.
// –í —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –≥–¥–µ App.js —É–ø—Ä–æ—â–µ–Ω, —ç—Ç–æ—Ç –±–ª–æ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ HomePage.js.
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
    iconRetinaUrl: L.Icon.Default.prototype.options.iconRetinaUrl, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Ç–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–ª–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ
    iconUrl: L.Icon.Default.prototype.options.iconUrl,
    shadowUrl: L.Icon.Default.prototype.options.shadowUrl,
});

// –ö–∞—Å—Ç–æ–º–Ω—ã–µ –∏–∫–æ–Ω–∫–∏ –º–∞—Ä–∫–µ—Ä–æ–≤
const customMarkerIcon = new Icon({
  iconUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png",
  shadowUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png",
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

const userLocationIcon = new Icon({
  iconUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png",
  shadowUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png",
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å—Ç—Ä–æ–∫–∏ WKT
const parseWktPoint = (wktString) => {
  if (!wktString || typeof wktString !== 'string') {
    return null;
  }
  const match = wktString.match(/POINT \(([^ ]+) ([^ ]+)\)/);
  if (match && match.length === 3) {
    const longitude = parseFloat(match[1]);
    const latitude = parseFloat(match[2]);
    if (!isNaN(longitude) && !isNaN(latitude)) {
      return { longitude, latitude };
    }
  }
  return null;
};

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –º–∞—Ä–∫–µ—Ä–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
function LocationMarker({ position }) {
  const map = useMap();

  useEffect(() => {
    if (position) {
      map.flyTo(position, map.getZoom());
    }
  }, [position, map]);

  return position === null ? null : (
    <Marker position={position} icon={userLocationIcon}>
      <Popup>–í—ã –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –∑–¥–µ—Å—å (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)!</Popup>
    </Marker>
  );
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∫–Ω–æ–ø–∫–∏ "–ú–æ—è –≥–µ–æ–ª–æ–∫–∞—Ü–∏—è"
function MapEventsHandler({ onLocateMe }) {
  const map = useMapEvents({});

  return (
    <div style={{
      position: 'absolute',
      bottom: '20px',
      right: '20px',
      zIndex: 1000
    }}>
      <button
        onClick={() => onLocateMe(map)}
        style={{
          width: '50px',
          height: '50px',
          borderRadius: '50%',
          backgroundColor: '#007bff',
          color: 'white',
          fontSize: '24px',
          border: 'none',
          cursor: 'pointer',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          boxShadow: '0 2px 5px rgba(0,0,0,0.2)'
        }}
        title="–ú–æ—è –≥–µ–æ–ª–æ–∫–∞—Ü–∏—è"
      >
        üìç
      </button>
    </div>
  );
}

// –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç HomePage
function HomePage() {
  const [places, setPlaces] = useState([]);
  const [userLocation, setUserLocation] = useState(null);

  const kazanCoordinates = [55.7961, 49.1064];
  const initialZoom = 15;
  const radiusKm = 15; // –£–≤–µ–ª–∏—á–µ–Ω —Ä–∞–¥–∏—É—Å –¥–ª—è —Ç–µ—Å—Ç–∞

  const fixedTestLatitude = 55.7961;
  const fixedTestLongitude = 49.1064;

  const fetchPlaces = useCallback(async (latitude = null, longitude = null) => {
    let url = `${process.env.REACT_APP_API_BASE_URL}/api/places/`;
    if (latitude !== null && longitude !== null) {
      url = `${process.env.REACT_APP_API_BASE_URL}/api/places/nearest/?lat=${latitude}&lon=${longitude}&radius_km=${radiusKm}`;
    }

    try {
      const response = await axios.get(url);
      if (response.status !== 200) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = response.data;

      if (data && data.type === 'FeatureCollection' && Array.isArray(data.features)) {
          setPlaces(data.features);
      } else {
          console.error("API response is not a valid GeoJSON FeatureCollection:", data);
          setPlaces([]);
      }
    } catch (error) {
      console.error("Error fetching places:", error);
      setPlaces([]);
    }
  }, [radiusKm]);

  useEffect(() => {
    fetchPlaces();
  }, [fetchPlaces]);

  const handleLocateMe = useCallback((mapInstance) => {
    const fixedLatLng = L.latLng(fixedTestLatitude, fixedTestLongitude);
    setUserLocation(fixedLatLng);
    mapInstance.flyTo(fixedLatLng, mapInstance.getZoom());
    fetchPlaces(fixedTestLatitude, fixedTestLongitude);
  }, [fetchPlaces, fixedTestLatitude, fixedTestLongitude]);

  return (
    // –£–î–ê–õ–Ø–ï–ú div —Å className="main" –∏ style={{ height: 'calc(100vh - 80px)', width: '100%' }}
    // MapContainer —Ç–µ–ø–µ—Ä—å –±—É–¥–µ—Ç –∑–∞–Ω–∏–º–∞—Ç—å 100% –≤—ã—Å–æ—Ç—ã —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ (main –≤ Layout)
    <MapContainer
      center={kazanCoordinates}
      zoom={initialZoom}
      scrollWheelZoom={true}
      style={{ height: '100%', width: '100%' }} // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É 100%
    >
      <TileLayer
        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
      />

      <LocationMarker position={userLocation} />

      <MapEventsHandler onLocateMe={handleLocateMe} />

      {places.map(place => {
        const coords = parseWktPoint(place.geometry);

        if (!coords) {
          console.warn("–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –º–µ—Å—Ç–æ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (WKT):", place);
          return null;
        }

        const distanceInfo = place.properties.distance !== null && place.properties.distance !== undefined
          ? `<br/>–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${place.properties.distance.toFixed(2)} –∫–º`
          : '';

        return (
          <Marker
            position={[coords.latitude, coords.longitude]}
            icon={customMarkerIcon}
            key={place.id || place.properties.id}
          >
            <Popup>
              <b>{place.properties.name}</b><br />
              {place.properties.description}
              {distanceInfo}
              {place.properties.image && (
                <img
                  src={place.properties.image}
                  alt={place.properties.name}
                  style={{ maxWidth: '100px', maxHeight: '100px', marginTop: '5px' }}
                />
              )}
              <p>–ö–∞—Ç–µ–≥–æ—Ä–∏–∏: {place.properties.categories}</p>
              <p>–†–µ–π—Ç–∏–Ω–≥: {place.properties.avg_rating ? place.properties.avg_rating.toFixed(1) : '–ù–µ—Ç'}</p>
              <p>–ó–∞–º–µ—Ç–æ–∫: {place.properties.notes_count}</p>
            </Popup>
          </Marker>
        );
      })}
    </MapContainer>
  );
}

export default HomePage;


